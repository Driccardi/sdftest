/**
 *    Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
 *  This software is the confidential and proprietary information of
 * NetSuite, Inc. ('Confidential Information'). You shall not
 * disclose such Confidential Information and shall use it only in
 * accordance with the terms of the license agreement you entered into
 * with NetSuite.
 *
 * The map/reduce script type is designed for scripts that need to handle large amounts of data. It is best suited for situations where the data can be divided into small, independent parts. When the script is executed, a structured framework automatically creates enough jobs to process all of these parts.
 *
 * When the CS Hub Automation processes order replacements, the resulting Replacement Sales Order is required to have a reference back to the credit memo (also generated by the CS Hub automation). To have the credit memo referenced on the replacement sales order, it must be in place (been generated in advance of the replacement sales order), however, the two processes are designed to not run sequentially for performance and efficiency reasons.
 * This could mean that at times, the replacement sales order is generated before the credit memo (even so by a few seconds), and hence a utility/service is needed, which checks (on a scheduled basis), the successful generation of the credit memo as well as the replacement sales order. Once this is established by the proposed service, the replacement sales order is expected to be stamped with the applicable credit meme for further processing.
 *
 * Version          Date                      Author                                Remarks
 * 1.0            2024/05/04           shekainah.castillo                       Initial Commit
 *
 *
 */

/**
 * @NApiVersion 2.1
 * @NScriptType MapReduceScript
 * @NModuleScope SameAccount
 */

define(['N/runtime', 'N/search', 'N/record'],  (runtime, search, record) => {
    let strLogTitle;
    const getInputData = () => {
        try{
            strLogTitle = 'getInputData';
            let intSavedSearch = runtime.getCurrentScript().getParameter('custscript_ns_cs_hub_associate_cm_srch');
            let objTransactionSearch = search.load(intSavedSearch);
            let objSearchResultCount = objTransactionSearch.runPaged().count;
            log.debug("SearchObj result count", objSearchResultCount);

            if (objSearchResultCount > 0) {
                return objTransactionSearch;
            } else {
                log.audit('No data to process', 'Saved search is not getting results')
                return false;
            }
        }catch (e) {
            log.error("Error at [" + strLogTitle + "] function",
                'Message:<\/br>' + e.message + '<\/br><\/br>Stack:<\/br>' + e.stack);
        }
    }

    const map = (context) => {
        try{
            strLogTitle = 'map';
            let objSearchResults = JSON.parse(context.value);
            let intOrderID = parseInt(objSearchResults.id);
            let strTranline = objSearchResults.values["custrecord_cshub_casestep_tran_line_id.custbody_cshub_createdfromcasedetail"];
            let intCaseID = parseInt(objSearchResults.values.formulatext);

            let objCase = {
                'orderID' : intOrderID,
                'tranline' : strTranline,
                 'case' : intCaseID
            }
            log.debug(strLogTitle,objCase);

            let intCreditMemo = findRelatedCM(objCase);

            if(intCreditMemo){
                record.submitFields({
                    type: record.Type.SALES_ORDER,
                    id: intOrderID,
                    values: {
                        custbody_cs_hub_related_credit_memo : intCreditMemo
                    }
                });
                log.audit(strLogTitle, 'Sales Order Linked to Credit Memo')
            }

        }catch (e) {
            log.error("Error at [" + strLogTitle + "] function",
                'Message:<\/br>' + e.message + '<\/br><\/br>Stack:<\/br>' + e.stack);
        }
    }

    const summarize = (summary)=>  {
        try{
            strLogTitle = 'summarize';

            log.audit(strLogTitle, 'Execution time in seconds: ' + summary.seconds +
                ' | Usage Consumed: ' + summary.usage +
                ' | Usage Consumed: ' + summary.yields +
                ' | Concurrency Number: ' + summary.concurrency
            );
            if (summary.inputSummary.error !== null) {
                log.error('Input Error: ', summary.inputSummary.error);
            }
            summary.mapSummary.errors.iterator().each(function (key, error) {
                log.error('Map Error: ', error);
                return true;
            });

        }catch (e) {
            log.error("Error at [" + strLogTitle + "] function",
                'Message:<\/br>' + e.message + '<\/br><\/br>Stack:<\/br>' + e.stack);
        }
    }

    const findRelatedCM = (objCase) => {
        strLogTitle ='findRelatedCM'
        let intSavedSearch = runtime.getCurrentScript().getParameter('custscript_ns_cs_hub_cm_to_print_on_so');
        let objTransactionSearch = search.load(intSavedSearch);
        objTransactionSearch.filters.push(
            search.createFilter({
                name: "internalid",
                join: "CUSTRECORD_CSHCD_CSACTN_STEP_PARENT_CASE",
                operator: search.Operator.ANYOF,
                values: parseInt(objCase.case),
            }),
            search.createFilter({
                name: "custrecord_cshub_casestep_tran_line_id",
                operator: search.Operator.IS,
                values: objCase.tranline,
            }),
        );
        var searchResultCount = objTransactionSearch.runPaged().count;

        log.debug("objTransactionSearch result count", searchResultCount);
        let intCreditMemo;
        objTransactionSearch.run().each(function (result) {
            intCreditMemo = result.getValue({
                name: "internalid",
                join: "CUSTRECORD_CSHCD_CSACTN_STEP_CRTD_TRAN",
            });
        });
        log.debug(strLogTitle, intCreditMemo)
        return intCreditMemo;
    }

    return {
        getInputData: getInputData,
        map: map,
        summarize: summarize
    }
})